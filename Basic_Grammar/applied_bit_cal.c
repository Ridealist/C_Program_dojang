#include <stdio.h>

int appliedBitCalculate()
{
    // 1. 시프트 연산과 2의 거듭 제곱
    unsigned char num1 = 1;    //   1: 0000 0001

    printf("%u\n", num1 << 1);    //   2: 0000 0010: 2
    printf("%u\n", num1 << 2);    //   4: 0000 0100: 2^2
    printf("%u\n", num1 << 3);    //   8: 0000 1000: 2^3
    printf("%u\n", num1 << 4);    //  16: 0001 0000: 2^4
    printf("%u\n", num1 << 5);    //  32: 0010 0000: 2^5
    printf("%u\n", num1 << 6);    //  64: 0100 0000: 2^6
    printf("%u\n", num1 << 7);    // 128: 1000 0000: 2^7


    // 2. 시프트 연산으로 자릿수를 넘는 경우
    unsigned char num2 = 240;    // 240: 1111 0000 -> 1btye = 8bit
    unsigned char num3 = 15;     //  15: 0000 1111

    unsigned char num4, num5;

    num4 = num2 << 2;    // num1의 비트 값을 왼쪽으로 2번 이동
    num5 = num3 >> 2;    // num2의 비트 값을 오른쪽으로 2번 이동

    printf("%u\n", num4);    // 192: 1100 0000: 맨 앞의 11이 사라져서 11000000이 됨
    printf("%u\n", num5);    //   3: 0000 0011: 맨 뒤의 11이 사라져서 00000011이 됨
    printf("\n");

    // 4. 비트 연산자로 플래그 처리
    unsigned char flag = 0;

    // 플래그 비트 켜기
    // 플래그 |= 마스크
    flag |= 1;    // 0000 0001 마스크와 비트 OR로 여덟 번째 비트를 켬
    flag |= 2;    // 0000 0010 마스크와 비트 OR로 일곱 번째 비트를 켬
    flag |= 4;    // 0000 0100 마스크와 비트 OR로 여섯 번째 비트를 켬

    printf("%u\n", flag);    // 7: 0000 0111

    if (flag & 1)    // & 연산자로 0000 0001 비트가 켜져 있는지 확인
        printf("0000 0001은 켜져 있음\n");
    else
        printf("0000 0001은 꺼져 있음\n");

    if (flag & 2)    // & 연산자로 0000 0010 비트가 켜져 있는지 확인
        printf("0000 0010은 켜져 있음\n");
    else
        printf("0000 0010은 꺼져 있음\n");

    if (flag & 4)    // & 연산자로 0000 0100 비트가 켜져 있는지 확인
        printf("0000 0100은 켜져 있음\n");
    else
        printf("0000 0100은 꺼져 있음\n");

    printf("\n");

    // 플래그 비트 끄기
    // 플래그 &= ~마스크
    unsigned char flag2 = 7;  // 0000 0111;

    // flag ^= 6;  // 0000 0110 -> 0000 0001

    flag2 &= ~2;  // 1111 1101, 마스크 값 2의 비트를 뒤집은 뒤 비트 AND로 일곱 번째 비트를 끔

    printf("%u\n", flag);    // 5: 0000 0101

    if (flag2 & 1)    // & 연산자로 0000 0001 비트가 켜져 있는지 확인
        printf("0000 0001은 켜져 있음\n");
    else
        printf("0000 0001은 꺼져 있음\n");

    if (flag2 & 2)    // & 연산자로 0000 0010 비트가 켜져 있는지 확인
        printf("0000 0010은 켜져 있음\n");
    else
        printf("0000 0010은 꺼져 있음\n");

    if (flag2 & 4)    // & 연산자로 0000 0100 비트가 켜져 있는지 확인
        printf("0000 0100은 켜져 있음\n");
    else
        printf("0000 0100은 꺼져 있음\n");

    printf("\n");

    // 플래그비트 토글(toggle) : 비트 on <-> off
    // 플래그 ^= 마스크
    unsigned char toggle = 7;    // 7: 0000 0111

    toggle ^= 2;    // 0000 0010 마스크와 비트 XOR로 일곱 번째 비트를 토글
    toggle ^= 8;    // 0000 1000 마스크와 비트 XOR로 다섯 번째 비트를 토글

    printf("%u\n", toggle);    // 13: 0000 1101

    if (toggle & 1)    // & 연산자로 0000 0001 비트가 켜져 있는지 확인
        printf("0000 0001은 켜져 있음\n");
    else
        printf("0000 0001은 꺼져 있음\n");

    if (toggle & 2)    // & 연산자로 0000 0010 비트가 켜져 있는지 확인
        printf("0000 0010은 켜져 있음\n");
    else
        printf("0000 0010은 꺼져 있음\n");

    if (toggle & 4)    // & 연산자로 0000 0100 비트가 켜져 있는지 확인
        printf("0000 0100은 켜져 있음\n");
    else
        printf("0000 0100은 꺼져 있음\n");

    if (toggle & 8)    // & 연산자로 0000 1000 비트가 켜져 있는지 확인
        printf("0000 1000은 켜져 있음\n");
    else
        printf("0000 1000은 꺼져 있음\n");

    return 0;
}